-- Stolen 

var ffi = require("ffi")

var ENCODED_LEN = 108
var HASH_LEN = 32
var OPTIONS = {
  t_cost = 2,
  m_cost = 12,
  parallelism = 1,
  argon2d = false,
}

ffi.cdef(``
typedef enum Argon2_type { Argon2_d = 0, Argon2_i = 1 } argon2_type;

int argon2i_hash_encoded(const uint32_t t_cost,
                         const uint32_t m_cost,
                         const uint32_t parallelism,
                         const void *pwd, const size_t pwdlen,
                         const void *salt, const size_t saltlen,
                         const size_t hashlen, char *encoded,
                         const size_t encodedlen);

int argon2d_hash_encoded(const uint32_t t_cost,
                         const uint32_t m_cost,
                         const uint32_t parallelism,
                         const void *pwd, const size_t pwdlen,
                         const void *salt, const size_t saltlen,
                         const size_t hashlen, char *encoded,
                         const size_t encodedlen);

int argon2_verify(const char *encoded, const void *pwd, const size_t pwdlen,
                  argon2_type type);

const char *argon2_error_message(int error_code);
``)

var buf = ffi.new("char[?]", ENCODED_LEN)
var argon2_t = ffi.typeof(ffi.new("argon2_type"))
var c_type_i = ffi.new(argon2_t, "Argon2_i")
var c_type_d = ffi.new(argon2_t, "Argon2_d")

var lib = ffi.load("argon2")

var _M = {
  _VERSION = "1.0.0",
  _AUTHOR = "Thibault Charbonnier",
  _LICENSE = "MIT",
  _URL = "https://github.com/thibaultCha/lua-argon2-ffi",
}

_M.encrypt = \pwd, salt, opts ->
  if type(pwd) ~= "string"
    error("bad argument #1 to 'encrypt' (string expected, got "..type(pwd)..")", 2)
  else if type(salt) ~= "string"
    error("bad argument #2 to 'encrypt' (string expected, got "..type(salt)..")", 2)

  if opts == nil
    opts = OPTIONS
  else if type(opts) ~= "table"
    error("bad argument #3 to 'encrypt' (table expected, got "..type(opts)..")", 2)
  else
    for k, v in pairs(OPTIONS)
      var o = opts[k]
      if o == nil
        opts[k] = v
      else if k ~= "argon2d" and type(o) ~= "number"
        error("expected " .. k .. " to be a number", 2)

  var res
  if opts.argon2d
    res = lib.argon2d_hash_encoded(opts.t_cost, opts.m_cost, opts.parallelism, pwd, #pwd, salt, #salt, HASH_LEN, buf, ENCODED_LEN)
  else
    res = lib.argon2i_hash_encoded(opts.t_cost, opts.m_cost, opts.parallelism, pwd, #pwd, salt, #salt, HASH_LEN, buf, ENCODED_LEN)

  if res == 0
    return ffi.string(buf)

  var c_msg = lib.argon2_error_message(res)
  return nil, ffi.string(c_msg)

_M.verify = \hash, plain ->
  if type(hash) ~= "string"
    error("bad argument #1 to 'verify' (string expected, got " .. type(hash) .. ")", 2)
  else if type(plain) ~= "string"
    error("bad argument #2 to 'verify' (string expected, got "..type(plain)..")", 2)
  

  var argon2d = string.find(hash, "argon2d") ~= nil
  var c_type = argon2d and c_type_d or c_type_i

  var res = lib.argon2_verify(hash, plain, #plain, c_type)
  if res == 0
    return true
  return false, "The password did not match."

return _M