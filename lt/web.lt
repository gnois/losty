var json = require('cjson.safe')
var status = require('losty.status')
var accept = require('losty.accept')
var router = require('losty.router')
var dispatch = require('losty.dispatch')
var req = require('losty.req')
var res = require('losty.res')

-- run once, for later math.random
math.randomseed(ngx.time())

var HTML = "text/html"
var JSON = "application/json"

-- each web instance has a different router 
return ->

	var rtr = router()
	
	var route = \root ->
		var r = {}
		for _, method in pairs({'get', 'post', 'put', 'delete', 'patch', 'options'}) -- 'trace', 'connect'
			r[method] = \path, f, ... ->
				if string.sub(path, 1, 1) ~= '/'
					error("routed path " .. path .. " should start with '/'")
				if root
					path = root .. path
				rtr.set(string.upper(method), path, f, ...)
		return r


	var must_no_body = \method, code ->
		return method == 'HEAD' or code == 204 or code == 205 or code == 304


	-- errors will only be used for HTTP status >= 400 and 
	-- can be true, nil or table indexed by HTTP status number, eg: { [400] = "<html> error message markup </html>" }
	var run = \errors ->
		var body
		var method = req.method
		-- so that we don't need to register HEAD path
		if method == 'HEAD'
			method = 'GET'
		var handlers, params = rtr.match(method, req.uri)
		if handlers
			req.params = params
			var ok, trace = xpcall( ->
				body = dispatch(handlers, req, res)
			, \err ->
				return debug.traceback(err, 2)
			)
			
			if ok
				if not res.status
					error("response status required", 2)
				-- status < 200 or >= 300 can have no content, so no content-type needed
				if res.status >= 200 and res.status < 300 or body
					if not must_no_body(req.method, res.status) and not res.headers['Content-Type']
						error("Content-Type header required", 2)
			else
				res.status = 500
				ngx.log(ngx.ERR, trace)
		else
			res.status = 404

		-- for status 400 above without body:
		-- 1. if json is requested, provide default response 
		-- 2. if text/* is requested
			-- if errors is true, fall back to nginx error_page
			-- else if errors is table, use error[status] html
			-- else generate text/plain error msg
		if not body and res.status >= 400
			var pref = accept(req.headers["Accept"], {HTML, JSON})
			var ctype = tostring(pref[1])
			if req.method ~= 'HEAD'
				if ctype == JSON
					body = json.encode({ fail = status(res.status) })
				else
					if errors == true
						ngx.exit(res.status)
					else if errors
						body = errors[res.status]
				
					if not body
						ctype = "text/plain"
						body = status(res.status)
			res.headers['Content-Type'] = ctype

		res.send()
		if not must_no_body(req.method, res.status)
			if 'function' == type(body)
				var co = coroutine.create(body)
				do
					var ok, val = coroutine.resume(co)
					if ok and val
						ngx.print(val)
						ngx.flush(true)
				until not ok
			else
				ngx.print(body)
		ngx.eof()


	return {
		route = route
		, run = run
	}

