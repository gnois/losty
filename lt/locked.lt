-- Cache lock abstraction, from
-- https://github.com/openresty/lua-resty-lock#for-cache-locks

--`` 
nginx.conf

http {
   lua_shared_dict lock_name 1m;
   ...

``

var locker = require('resty.lock')

-- Usage 1: Read from cache if exist, else add to cache
-- Usage 2: Check if file exists, else write the file

-- read(key) tries to read the target, return non-nil if succeed
-- write() creates the target if it havent existed

-- returns value from read(), or write()

return \lock_name, key, expiry, read, write, ...->
	-- check if exist
	var val, err = read(key)
	if val ~= nil
		return val

	-- not exist, acquire lock...
	var lock = locker.new(@, lock_name, {exptime = expiry})
	var ok
	ok, err = lock.lock(@, key)
	if not ok
		return nil, err

	-- lock acquired. while waiting, someone might have created the target
	val, err = read(key)
	if val == nil
		val, err = write(key, ...)
	
	-- release lock
	ok, err = lock.unlock(@)
	return val, err


