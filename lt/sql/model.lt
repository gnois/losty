var to = require('losty.to')
var c = require('losty.exec')
var tbl = require('losty.tbl')

var K = {}

--```
K.migrate = \db, migrations ->
	assert('table' == type(migrations), "migration schemas must be a table of { [index] = [[sql]] } where index is sortable")
	
	db.connect()
	var e = db.one("from pg_class where relname = 'migrations'")
	if not e or not e[1]
		print("Creating migration index table...")
		e = db.run("CREATE TABLE migrations (index varchar(16) primary key)")
		if not e
			db.disconnect()
			return false

	var exists = {}
	e = db.select("index FROM migrations")
	if e 
		for _, row in ipairs(e)
			exists[row.index] = true

	var tuples = {}
	for k, v in pairs(migrations) do
		table.insert(tuples, { k, v })
	table.sort(tuples, \a, b -> return a[1] < b[1])

	for _, v in ipairs(tuples)
		var index, sql = tostring(v[1]), v[2]
		if not exists[index]
			print("Migrating ", index)
			var ok, err = db.run(sql)
			if ok 
				db.insert("migrations (index) VALUES (?)", index)
			else
				print(err)
				break
		else
			print(index, " already migrated")
	
	db.disconnect()
	return true

--```

	
K.migrate = \db, migrations ->
	assert('table' == type(migrations), "migration schemas must be an array of {sql, ...} where sql are strings")
	
	var ok = true
	var err
	db.connect()
	for _, v in ipairs(migrations)
		var sql = to.trimmed(v)
		if #sql > 0
			ok, err = db.run(sql)
			if tonumber(err) -- err is 0 when no statement to execute, maybe bcoz all are comments
				print(c.onblue, c.yellow, c.bright, "        ==> ", err .. ' query ok', c.reset)
			else
				print(c.onred, c.white, c.bright, "        >>>> ", tbl.dump(err), c.reset)
				break
			

	db.disconnect()
	if not ok and err ~= 0
		return false
	return true


K.seed = \db, fn ->
	assert('function' == type(fn), "seed must take a function which accepts a database handle")
	
	db.connect()
	-- dont start tx, in case fn() also has tx causing nested tx and PG issues warning/error: already inside a transaction
	-- db.begin()
	
	var ok, trace = xpcall(fn, \err ->
		return debug.traceback(err, 2)
	, db)

	if not ok
		print(c.syan, trace, c.reset)
		print(c.onred, c.white, c.bright, "  Transaction not committed  ", c.reset)
		--db.rollback()
		db.disconnect()
		return false

	-- db.commit()
	db.disconnect()
	return true


return K
